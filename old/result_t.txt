punctuation@1 (2.32) #
identifier@1 (4.0) include
literal@1 (1.5) path/to/code.c
identifier@1 (4.0) name
keyword@3 (3.1) i8
keyword@3 (3.2) i16
keyword@3 (3.3) i32
keyword@3 (3.4) i64
keyword@3 (3.5) u8
keyword@3 (3.6) u16
keyword@3 (3.7) u32
keyword@3 (3.8) u64
keyword@3 (3.9) f32
keyword@3 (3.10) f64
keyword@4 (3.11) void
keyword@4 (3.13) true
keyword@4 (3.14) false
keyword@4 (3.12) null
keyword@7 (3.11) void
punctuation@7 (2.3) *
identifier@7 (4.0) f
punctuation@7 (2.26) (
keyword@7 (3.3) i32
punctuation@7 (2.6) <
keyword@7 (3.3) i32
punctuation@7 (2.24) ,
keyword@7 (3.3) i32
punctuation@7 (2.8) >
identifier@7 (4.0) g
punctuation@7 (2.27) )
punctuation@7 (2.28) {
keyword@8 (3.25) return
literal@8 (1.1) 0
punctuation@8 (2.22) ;
punctuation@9 (2.29) }
keyword@11 (3.26) struct
identifier@11 (4.0) Point
punctuation@11 (2.28) {
keyword@12 (3.3) i32
identifier@12 (4.0) x
punctuation@12 (2.22) ;
keyword@13 (3.3) i32
identifier@13 (4.0) y
punctuation@13 (2.22) ;
keyword@14 (3.4) i64
identifier@14 (4.0) Add
punctuation@14 (2.26) (
identifier@14 (4.0) Point
punctuation@14 (2.3) *
identifier@14 (4.0) self
punctuation@14 (2.27) )
punctuation@14 (2.28) {
keyword@15 (3.25) return
punctuation@15 (2.26) (
keyword@15 (3.4) i64
punctuation@15 (2.27) )
punctuation@15 (2.26) (
identifier@15 (4.0) self
punctuation@15 (2.23) .
identifier@15 (4.0) x
punctuation@15 (2.1) +
identifier@15 (4.0) self
punctuation@15 (2.23) .
identifier@15 (4.0) y
punctuation@15 (2.27) )
punctuation@15 (2.22) ;
punctuation@16 (2.29) }
punctuation@17 (2.29) }
keyword@23 (3.1) i8
identifier@23 (4.0) a
punctuation@23 (2.22) ;
keyword@24 (3.3) i32
identifier@24 (4.0) b
punctuation@24 (2.25) =
punctuation@24 (2.26) (
keyword@24 (3.3) i32
punctuation@24 (2.27) )
identifier@24 (4.0) a
punctuation@24 (2.22) ;
literal@25 (1.5) 가나다abc
literal@25 (1.4) a
literal@26 (1.1) 123
literal@26 (1.3) 123.45
literal@26 (1.1) -13
literal@26 (1.3) -0.0
literal@26 (1.2) 0x0df3
literal@26 (1.2) 0XA34F
literal@26 (1.1) -123
identifier@28 (4.0) a
punctuation@28 (2.1) +
identifier@28 (4.0) b
punctuation@28 (2.2) -
identifier@28 (4.0) c
punctuation@28 (2.3) *
identifier@28 (4.0) d
punctuation@28 (2.4) /
identifier@28 (4.0) e
punctuation@28 (2.5) %
identifier@28 (4.0) f
punctuation@28 (2.6) <
identifier@28 (4.0) g
punctuation@28 (2.7) <=
identifier@28 (4.0) h
punctuation@28 (2.8) >
identifier@28 (4.0) i
punctuation@28 (2.9) >=
identifier@28 (4.0) j
punctuation@28 (2.10) ==
identifier@28 (4.0) k
punctuation@28 (2.11) !=
identifier@28 (4.0) l
identifier@29 (4.0) a
punctuation@29 (2.16) &
identifier@29 (4.0) b
punctuation@29 (2.17) |
identifier@29 (4.0) c
punctuation@29 (2.18) ^
identifier@29 (4.0) d
punctuation@29 (2.19) <<
identifier@29 (4.0) e
punctuation@29 (2.20) >>
identifier@29 (4.0) f
punctuation@30 (2.3) *
identifier@30 (4.0) a
punctuation@30 (2.16) &
identifier@30 (4.0) a
punctuation@30 (2.2) -
identifier@30 (4.0) a
punctuation@30 (2.14) !
identifier@30 (4.0) a
punctuation@30 (2.15) ~
identifier@30 (4.0) a
keyword@32 (3.16) if
punctuation@32 (2.26) (
punctuation@32 (2.27) )
punctuation@32 (2.28) {
punctuation@33 (2.29) }
keyword@35 (3.16) if
punctuation@35 (2.26) (
punctuation@35 (2.27) )
punctuation@35 (2.28) {
punctuation@36 (2.29) }
keyword@36 (3.17) else
punctuation@36 (2.28) {
punctuation@37 (2.29) }
keyword@39 (3.16) if
punctuation@39 (2.26) (
punctuation@39 (2.27) )
punctuation@39 (2.28) {
punctuation@40 (2.29) }
keyword@40 (3.17) else
keyword@40 (3.16) if
punctuation@40 (2.26) (
punctuation@40 (2.27) )
punctuation@40 (2.28) {
punctuation@41 (2.29) }
keyword@41 (3.17) else
punctuation@41 (2.28) {
punctuation@42 (2.29) }
keyword@44 (3.18) while
punctuation@44 (2.26) (
punctuation@44 (2.27) )
punctuation@44 (2.28) {
punctuation@45 (2.29) }
keyword@47 (3.19) for
punctuation@47 (2.26) (
punctuation@47 (2.27) )
punctuation@47 (2.28) {
punctuation@48 (2.29) }
keyword@50 (3.20) switch
punctuation@50 (2.26) (
punctuation@50 (2.27) )
punctuation@50 (2.28) {
keyword@51 (3.21) case
literal@51 (1.1) 0
punctuation@51 (2.21) :
keyword@52 (3.23) break
punctuation@52 (2.22) ;
keyword@53 (3.21) case
literal@53 (1.1) 1
punctuation@53 (2.21) :
keyword@54 (3.24) continue
punctuation@54 (2.22) ;
keyword@55 (3.22) default
punctuation@55 (2.21) :
punctuation@56 (2.29) }
keyword@58 (3.27) enum
identifier@58 (4.0) color
punctuation@58 (2.28) {
identifier@59 (4.0) RED
punctuation@59 (2.24) ,
identifier@60 (4.0) GREEN
punctuation@60 (2.25) =
literal@60 (1.1) 10
punctuation@60 (2.24) ,
identifier@61 (4.0) BLUE
punctuation@62 (2.29) }
punctuation@64 (2.32) #
identifier@64 (4.0) defer
punctuation@65 (2.32) #
identifier@65 (4.0) const
punctuation@66 (2.32) #
identifier@66 (4.0) volatile