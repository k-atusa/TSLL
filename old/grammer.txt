front: TSLL-C
C의 낡은 문법적 제한을 최신 언어와 비슷하게 개선하고, 더 직관적이고 명확한 코드를 작성하도록 하는 C
간결한 문법과 복잡성을 최소화한 컴파일러 제작이 목표

1. 모듈
파일명 기반 모듈 시스템 사용
대문자로 시작하는 변수, 구조체, 함수, 필드만 public 하여 다른 파일에서 사용 가능
#include "filepath" name

2. 리터럴 표기
불리언과 널 (내부적으로 정수와 동일): true (=1), false (=0), null (=0)
10진수, 16진수 리터럴: 123, 0x1a2F 등
실수: 3.1415
char 표기는 단일 따옴표 '' (실제 타입은 u8)
string 표기는 쌍따옴표 "" (실제 타입은 u8*, C문자열처럼 널 문자로 끝나는 데이터 영역에 대한 포인터)
escape은 \0 \t \r \n \' \" \\ 지원

3. 타입
원시 타입: i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, void
타입 접미사: 포인터*, 포인터[], 배열[N], 함수(...)
빈 반환값: void
캐스팅: (T)id
ex. void*, i32[][], f32[4], i64(i64, i64)

4. 변수
T id;
T id = expr;
전역변수의 초기화는 리터럴로만 가능하다

5. 배열
크기 없는 배열 (T[])는 포인터 (T*)와 동일
정수 리터럴의 크기를 가진 배열 (T[N])은 연속된 T들의 메모리 덩어리 (함수 인자 전달 등에서도 덩어리가 통째로 복사됨)
T[] id; (T* id;)
T[4] id; (sizeof(id) == 4*sizeof(T))
인덱싱 (id[N])은 포인터 연산 (*(id + N))과 동일
배열 인덱싱은 첫 항목에 대한 포인터 연산으로 처리

6. 포인터
null, sizeof
함수포인터 : T(T, T, ...) id
구조체에 대한 포인터라면 . 사용 시 자동으로 (*T).data로 바꿔준다

7. 이항연산자
산술: + - * / %
관계: < <= > >= == !=
논리: && ||
비트: & | ^ << >>
구조체/모듈 접근: .

8. 단항연산자
메모리: 역참조 *, 참조 &
산술: -
논리: !
비트: ~

9. 일반 제어문
정수 타입만 조건에 들어가는 bool 값이 될 수 있다. 0만 false고 나머지는 true
if (bool) scope, if (bool) scope else scope, if (bool) scope else if (bool) scope
while (bool) scope

10. 고급 제어문
for (stat; bool; stat) scope
switch (expr) {case literal: ... default: ...} (정수만 받을 수 있다, continue를 넣지 않으면 자동으로 break가 삽입된다)
break; continue;

11. 함수
정의: T id(T parm, T parm...) scope (id는 함수 포인터 타입이다)
반환: return expr;
자동으로 호이스팅되어 인식된다
id(...) (함수 포인터 타입을 호출한다)

12. 가변 인자 함수
#va_arg T id(...) {...}
함수의 마지막 두 인자의 타입은 void**와 정수여야 한다
컴파일러가 함수 호출시 자동으로 남는 인자를 묶어서 전달한다
묶이는 인자들은 포인터 타입이여야 한다

13. 구조체
struct id {T id; T id; ...}
사용 시 struct를 붙일 필요 없이 자동으로 타입의 일부로 인식된다
자동으로 호이스팅되어 인식된다

14. 구조체 메소드
T T.id(..) {...}
함수명 앞에 구조체 타입명을 붙일 경우 메서드가 된다
메서드의 첫 인자는 구조체 포인터여야 한다
(메서드는 구조체의 메모리를 차지하지 않음, 단지 컴파일러가 처리하는 함수일 뿐)

15. 열거형
enum id {id, id = literal, ...}
열거형은 정수형의 별칭이다. 정수를 받는 자리에 쓸 수 있다
리터럴 지정 없는 열거형은 0부터 시작하며 다음 이름에 1씩 더한 수를 부여한다
리터럴로 해당하는 정수를 직접 지정할 수 있다
열거형은 해당 정수들을 모두 표현할 수 있는 부호 있는 정수 타입 중 가장 작은 타입을 부여받는다

16. 컴파일러 지시
주석: //... 과 /* ... */
컴파일러 지시: #order ... 형태
#defer stat (지연 문장은 scope 끝나기 직전에 자동삽입)
컴파일러가 스코프 컴파일 시 스택에 쌓았다가 종료시 역순으로 자동삽입함 (선언 시점의 값을 기억하지 않음, 단순 치환과 동일)
#const T id = expr; (id에 값을 재할당하는 시도를 막음, 포인터로 이 제약이 풀릴 수 있음)
#volatile T id = expr; (id와 관련된 최적화를 막음)
#raw_c "..." (컴파일 타겟 C에 직접 코드 삽입)
#func_c id id ... "..." (id를 사용하여 C 함수를 호출, id는 컴파일 시 이름 매핑을 위해 필요)
#raw_ir "..." (컴파일 타겟 IR에 직접 코드 삽입)
#func_ir id id ... "..." (id를 사용하여 IR 함수를 호출, id는 컴파일 시 이름 매핑을 위해 필요)

<module> ::= {<comment> | <compiler> | <var_declare> | <function_declare> | <struct_declare> | <enum_declare>}

<comment> ::= ("//" {_char_} "\n") | ("/*" {_char_} "*/")

<compiler> ::= "#" ("include" _string_ <identifier>) | ("raw_c" _string_) | ("func_c" {<identifier>} _string_) | ("raw_ir" _string_) | ("func_ir" {<identifier>} _string_)
    | ("const" <var_declare>) | ("volatile" <var_declare>) | ("va_arg" <function_declare>) | ("defer" <statement>)

<function_declare> ::= <type> [<identifier> "."] <identifier> "(" {<type> <identifier> ","} [<type> <identifier>] ")" <block>

<struct_declare> ::= "struct" <identifier> "{" {<type> <identifier> ";"} "}"

<enum_declare> ::= "enum" <identifier> "{" {<identifier> ["=" _int_] ","} "}"

<block> ::= "{" {<statement>} "}"

<statement> ::= <var_declare> | <var_assign> | (<function_call> ";") | <control_if> | <control_while> | <control_for> | <control_switch> | <compiler> | <comment> | ("break" ";") | ("continue" ";")

<var_declare> ::= <type> <identifier> ["=" <expression>] ";"

<var_assign> ::= <lvalue> "=" <expression> ";"

<function_call> ::= <identifier> "(" {<expression> ","} [<expression>] ")"

<control_if> ::= "if" "(" <expression> ")" <block> {"else" "if" "(" <expression> ")" <block>} ["else" <block>]

<control_while> ::= "while" "(" <expression> ")" <block>

<control_for> ::= "for" "(" <statement> <expression> <statement> ")" <block>

<control_switch> ::= "switch" "(" <expression> ")" "{" {"case" _int_ ":" {<statement>}} ["default" ":" {<statement>}] "}"

<literal> ::= _int_ | _float_ | _char_ | _string_ | "null" | "true" | "false"

<type> ::= "void" | "i8" | "i16" | "i32" | "i64" | "u8" | "u16" | "u32" | "u64" | "f32" | "f64"
    | (<type> "*") | (<type> "[" "]") | (<type> "[" _int_ "]") | (<type> "(" {<type> ","} [<type>] ")") | <identifier> "." <identifier>

<identifier> ::= A-Za-z {0-9A-Za-z_}

<lvalue> ::= <identifier> | (<identifier> "." <lvalue>) | ("*" <lvalue>) | (<lvalue> "[" <expression> "]") | ("(" <lvalue> ")")

<expression> ::= <literal> | <identifier> | <function_call> | "sizeof" "(" <expression> ")" | "(" <type> ")" <expression>
    | (_single_operator_ <expression>) | (<expression> _double_operator_ <expression>) | (<expression> "[" <expression> "]") | ("(" <expression> ")")
