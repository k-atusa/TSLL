front: TSLL-C
C의 낡은 문법적 제한을 최신 언어와 비슷하게 개선하고, 더 직관적이고 명확한 코드를 작성하도록 하는 C

1. 모듈
파일명 기반 모듈 시스템 사용
대문자로 시작하는 변수, 구조체, 함수, 필드만 public 하여 다른 파일에서 사용 가능
#include "filepath"

2. 타입
원시 타입: i8, i16, i32, i64, u8, u16, u32, u64, f32, f64
포인터 타입: void*, T*, 함수포인터
빈 반환값: void
캐스팅: (T)id
타입 선언 시 우선순위를 위해 괄호를 사용할 수 있다

3. 리터럴 표기
true (=1), false (=0), null (=0) 불리언과 널 표현은 내부적으로 정수와 동일하다
10진수, 16진수(0x...)
u8 한 글자 표기 '.'
u8* 리터럴 "..." (C문자열처럼 널 문자로 끝난다)

4. 변수
T id;
T id = expr;

5. 배열
배열이름은 첫 항목에 대한 포인터와 완전히 동일하다
T[N] id; (id의 실제 타입은 T*)
T[N] id = {...};
id[N]은 *(id + N)과 동일하다

6. 포인터
null, sizeof, malloc, free
함수포인터 : T<T, T, ...> id
구조체에 대한 포인터라면 . 사용 시 자동으로 (*T).data로 바꿔준다

7. 이항연산자
산술: + - * / %
관계: < <= > >= == !=
논리: && ||
비트: & | ^ << >>
구조체/모듈 접근: .

8. 단항연산자
메모리: 역참조 *, 참조 &
산술: -
논리: !
비트: ~

9. 일반 제어문
정수 타입만 조건에 들어가는 bool 값이 될 수 있다. 0만 false고 나머지는 true
if (bool) scope, if (bool) scope else scope, if (bool) scope else if (bool) scope
while (bool) scope

10. 고급 제어문
for (stat; bool; stat) scope
switch (expr) {case literal: ... default: ...} (정수만 받을 수 있다, continue를 넣지 않으면 자동으로 break가 삽입된다)
break; continue;

11. 함수
정의: T id(T parm, T parm...) scope (id는 함수 포인터 타입이다)
반환: return expr;
자동으로 호이스팅되어 인식된다
id(...) (함수 포인터 타입을 호출한다)

12. 구조체
struct id {T id; T id; ...}
사용 시 struct를 붙일 필요 없이 자동으로 타입의 일부로 인식된다
자동으로 호이스팅되어 인식된다

13. 구조체 메소드
struct id{
  T id(T id, T id, ...) {
    ...
  }
}
구조체 안에 함수를 선언할 경우 메서드가 된다 (메서드는 구조체의 메모리를 차지하지 않음, 단지 컴파일러가 처리하는 함수일 뿐)
메서드의 첫 인자는 구조체 포인터여야 한다

14. 열거형
enum id {id, id = literal, ...}
열거형은 정수형의 별칭이다. 정수를 받는 자리에 쓸 수 있다
리터럴 지정 없는 열거형은 0부터 시작하며 다음 이름에 1씩 더한 수를 부여한다
리터럴로 해당하는 정수를 직접 지정할 수 있다
열거형은 해당 정수들을 모두 표현할 수 있는 타입 중 가장 작은 타입을 부여받는다 (signed int 우선)

15. 컴파일러 지시
주석: //... 과 /* ... */
컴파일러 지시: #order ... 형태
#defer stat (지연 평가는 scope 끝나기 직전에 자동삽입)
컴파일러가 스코프 컴파일 시 스택에 쌓았다가 종료시 역순으로 자동삽입함 (선언 시점의 값을 기억하지 않음, 단순 치환과 동일)
#const id (id에 값을 재할당하는 시도를 막음, 포인터로 이 제약이 풀릴 수 있음)
#volatile id (id와 관련된 최적화를 막음)

==================== EBNF Expression #1 ====================

<module> ::= {<var_declare> | <function_declare> | <struct_declare> | <enum_declare> | <compiler> | <comment>}

<compiler> ::= "#" ("include" _literal_string_ <identifier> | "defer" <statement> | "const" <identifier> | "volatile" <identifier> | "raw_c" <literal_string> | "raw_ir" <literal_string>) "\n"

<function_declare> ::= <type> <identifier> ["<" <identifier> ">"] "(" {<type> <identifier> ","} [<type> <identifier>] ")" <block>

<struct_declare> ::= "struct" <identifier> "{" {(<type> <identifier> ";" | <function_declare>)} "}"

<enum_declare> ::= "enum" <identifier> "{" {<identifier> ["=" _literal_int_] ","} <identifier> ["=" _literal_int_] "}"

<block> ::= "{" {<statement>} "}"

<statement> ::= <var_declare> | <var_assign> | (<function_call> ";") | <control_if> | <control_while> | <control_for> | <control_switch> | <compiler> | <comment> | ("break" ";") | ("continue" ";")

<var_declare> ::= <type> <identifier> ["=" <expression>] ";"

<var_assign> ::= <identifier> "=" <expression> ";"

<function_call> ::= <identifier> "(" {<expression> ","} [<expression>] ")"

<control_if> ::= "if" "(" <expression> ")" <block> {"else" "if" "(" <expression> ")" <block>} ["else" <block>]

<control_while> ::= "while" "(" <expression> ")" <block>

<control_for> ::= "for" "(" <statement> <expression> <statement> ")" <block>

<control_switch> ::= "switch" "(" <expression> ")" "{" {"case" _literal_int_ ":" {<statement>}} ["default" ":" {<statement>}] "}"

<literal> ::= _literal_int_ | _literal_float_ | _literal_char_ | _literal_string_ | "null" | "true" | "false"

<type> ::= "void" | "i8" | "i16" | "i32" | "i64" | "u8" | "u16" | "u32" | "u64" | "f32" | "f64" | (<type> "*") | (<type> "<" {<type> ","} [<type>] ">") | (<type> "[" _literal_int_ "]")

<identifier> ::= A-Za-z {0-9A-Za-z_}

<expression> ::= <literal> | <identifier> | <function_call> | (_single_operator_ <expression>) | (<expression> _double_operator_ <expression>) | (<expression> "[" <expression> "]") | ("(" <expression> ")")

<comment> ::= ("//" {_char_} "\n") | ("/*" {_char_} "*/")
